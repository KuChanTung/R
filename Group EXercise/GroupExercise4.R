#******* Group information *******

#Group :

#Please rename this file to Group_.R
#Please write your code in each block.

#******* end of Group information *******


#****** 1.Please load the dataset "winequality-red.csv" and do some data managements. *****
library(data.table)

# load data
wine <- data.table::fread("winequality-red.csv", data.table = F)

#basic understanding
View(wine)
str(wine)

#check na
apply(wine, MARGIN = 2, function(x) sum(is.na(x)))

# empty string
apply(wine, MARGIN = 2, function(x) sum(x == ''))

#***** end of 1. *****


#****** 2. Please try to discover some patterns among predictors using PCA. *****
wine2 <- wine[, c(1:11)] # Center the data

View(win2)
X <- scale(as.matrix(wine2)) 


# Covariance matrix of standarized variables
#cov_X = cov(X)
cor_X = cor(X)


wine3 <- X[, c(1,3,6,7,8,9)]

cov_X = cov(wine3)

# Eigen decomposition of the covariance matrix
eigen_arrest = eigen(cov_X)

# 1st PC with loadings
eigen_arrest$vectors[, 1]

# 1st PC score
# as.matrix(X) %*% matrix(eigen_arrest$vectors[, 1], ncol = 1)
sum(eigen_arrest$vectors[, 1] ^ 2) # sum of squared loadings is 1

# PCA using princomp()
pc_arrest = princomp(wine3, scores = T)
# loadings of each PC
pc_arrest$loadings
# scores of each PC
pc_arrest$scores
# percentages of explained variance 
pc_arrest$sdev ^ 2 / sum((pc_arrest$sdev) ^ 2)
# A biplot should help you understand more about PCs
biplot(pc_arrest)
# Better biplot ggbiplot::ggbiplot() 
# library("devtools"); install_github("vqv/ggbiplot")
ggbiplot::ggbiplot(pc_arrest, labels = rownames(X), labels.size = 5)
ggbiplot::ggscreeplot(pc_arrest)


X2<- X[, -c(1,3,6,7,8,9)]
X2 <-cbind(X2, pc_arrest$scores[,c(1,2)])

# outcome y
X2 <- cbind(X2, scale(wine[,12]))

X2 <- data.frame(X2)
fit = lm(V8 ~ . , data = X2)
summary(fit)








#####################
wine4 <- wine[, 10]

View(wine4)
wine4$comp1 <- wine3[,1]
wine4$comp2 <- wine3[,2]
wine4$comp3 <- wine3[,3]
####################
#***** end of 2. *****


#****** 3. Please use the new features generated by PCA to
# build a predictive model to predict the target "quality. *****

# PCA using SVD
data(wine);
X = scale(as.matrix(wine)) # Center the data
svd_X = svd(X)
# We can recover the original scaled matrix
X_prime = svd_X$u %*% diag(c(svd_X$d[1:4])) %*% t(svd_X$v)
# Low-rank approximation (say rank = 2) or noise reduction of the original matrix
X_prime = svd_X$u %*% diag(c(svd_X$d[1:2], 0, 0)) %*% t(svd_X$v)
# Each columns in V contains loadings of each PC (information about columns)
svd_X$v

# Each column in U contains information about observations 
# Let's plot them onto a 2-D "concept map".
# We may also evaluate the similarity of states in terms of PC1 and PC2
U = data.frame(svd_X$u)
rownames(U) = rownames(USArrests)
colnames(U) = paste("PC_", 1:4, sep = "")
ggplot(U, aes(x = PC_1, y = PC_2,)) + geom_point(size = 3) + xlim(-0.3, 0.4) +
  geom_text(aes(label = rownames(U)), hjust = 0, vjust = 0, size = 5) + xlab("PC 1") + ylab("PC 2")

#***** end of 3. *****